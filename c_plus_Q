---

## 1. Two Sum

**Problem:**
Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to the target.


**Solution:**
```cpp
#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

// Function to return indices of the two numbers that add up to the target
vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> map; // value -> index
    for (int i = 0; i < nums.size(); i++) {
        int complement = target - nums[i];
        if (map.find(complement) != map.end()) {
            return {map[complement], i};
        }
        map[nums[i]] = i;
    }
    return {}; // return empty if no solution found
}
```
**Explanation:**
- Use a hashmap to store visited numbers and their indices.
- For each element, check if `target - current` exists in the map.
- Time Complexity: O(n), Space Complexity: O(n)

---

## 2. Best Time to Buy and Sell Stock

**Problem:**
Given an array `prices` where `prices[i]` is the price of a given stock on the ith day, find the maximum profit.

**Solution:**
```cpp
#include <vector>
#include <algorithm>
using namespace std;

int maxProfit(vector<int>& prices) {
    int minPrice = INT_MAX;
    int maxProfit = 0;
    for (int price : prices) {
        minPrice = min(minPrice, price);
        maxProfit = max(maxProfit, price - minPrice);
    }
    return maxProfit;
}
```
**Explanation:**
- Track the minimum price so far.
- Calculate profit for each day.
- Time Complexity: O(n), Space Complexity: O(1)

---

## 3. Maximum Subarray (Kadane's Algorithm)

**Problem:**
Find the contiguous subarray with the largest sum.

**Solution:**
```cpp
#include <vector>
#include <algorithm>
using namespace std;

int maxSubArray(vector<int>& nums) {
    int maxCurrent = nums[0];
    int maxGlobal = nums[0];
    for (int i = 1; i < nums.size(); i++) {
        maxCurrent = max(nums[i], maxCurrent + nums[i]);
        maxGlobal = max(maxGlobal, maxCurrent);
    }
    return maxGlobal;
}
```
**Explanation:**
- At each step, decide to include current element or start new subarray.
- Time Complexity: O(n), Space Complexity: O(1)

---

## 4. Move Zeroes

**Problem:**
Move all 0's to the end while maintaining the relative order of non-zero elements.

**Solution:**
```cpp
#include <vector>
using namespace std;

void moveZeroes(vector<int>& nums) {
    int insertPos = 0;
    for (int num : nums) {
        if (num != 0) {
            nums[insertPos++] = num;
        }
    }
    while (insertPos < nums.size()) {
        nums[insertPos++] = 0;
    }
}
```
**Explanation:**
- Shift non-zero values forward, fill remaining with zero.
- Time Complexity: O(n), Space Complexity: O(1)

---

## 5. Contains Duplicate

**Problem:**
Check if any value appears at least twice in the array.

**Solution:**
```cpp
#include <unordered_set>
#include <vector>
using namespace std;

bool containsDuplicate(vector<int>& nums) {
    unordered_set<int> seen;
    for (int num : nums) {
        if (seen.count(num)) return true;
        seen.insert(num);
    }
    return false;
}
```
**Explanation:**
- Use set to track unique values.
- Time Complexity: O(n), Space Complexity: O(n)

---

## 6. Product of Array Except Self

**Problem:**
Return array such that output[i] is product of all elements except nums[i].

**Solution:**
```cpp
#include <vector>
using namespace std;

vector<int> productExceptSelf(vector<int>& nums) {
    int n = nums.size();
    vector<int> output(n, 1);

    int prefix = 1;
    for (int i = 0; i < n; i++) {
        output[i] = prefix;
        prefix *= nums[i];
    }

    int suffix = 1;
    for (int i = n - 1; i >= 0; i--) {
        output[i] *= suffix;
        suffix *= nums[i];
    }

    return output;
}
```
**Explanation:**
- Two passes: one for prefix, one for suffix.
- Time Complexity: O(n), Space: O(1) extra (output not counted)

---

## 7. Maximum Product Subarray

**Problem:**
Find the contiguous subarray within an array which has the largest product.

**Solution:**
```cpp
#include <vector>
#include <algorithm>
using namespace std;

int maxProduct(vector<int>& nums) {
    int maxProd = nums[0], minProd = nums[0], result = nums[0];
    for (int i = 1; i < nums.size(); i++) {
        if (nums[i] < 0) swap(maxProd, minProd);
        maxProd = max(nums[i], nums[i] * maxProd);
        minProd = min(nums[i], nums[i] * minProd);
        result = max(result, maxProd);
    }
    return result;
}
```
**Explanation:**
- Track both max and min products because of negatives.
- Time Complexity: O(n)

---

## 8. Find Minimum in Rotated Sorted Array

**Problem:**
Find the minimum element in a rotated sorted array.

**Solution:**
```cpp
#include <vector>
using namespace std;

int findMin(vector<int>& nums) {
    int left = 0, right = nums.size() - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] > nums[right])
            left = mid + 1;
        else
            right = mid;
    }
    return nums[left];
}
```
**Explanation:**
- Binary search variation.
- Time Complexity: O(log n)

---

## 9. Search in Rotated Sorted Array

**Problem:**
Given rotated sorted array and target, return index or -1.

**Solution:**
```cpp
#include <vector>
using namespace std;

int search(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) return mid;

        if (nums[left] <= nums[mid]) {
            if (nums[left] <= target && target < nums[mid])
                right = mid - 1;
            else
                left = mid + 1;
        } else {
            if (nums[mid] < target && target <= nums[right])
                left = mid + 1;
            else
                right = mid - 1;
        }
    }
    return -1;
}
```
**Explanation:**
- Binary search with rotation check.
- Time Complexity: O(log n)

---

## 10. Merge Intervals

**Problem:**
Merge all overlapping intervals.

**Solution:**
```cpp
#include <vector>
#include <algorithm>
using namespace std;

vector<vector<int>> merge(vector<vector<int>>& intervals) {
    if (intervals.empty()) return {};
    sort(intervals.begin(), intervals.end());
    vector<vector<int>> merged;

    for (const auto& interval : intervals) {
        if (merged.empty() || merged.back()[1] < interval[0]) {
            merged.push_back(interval);
        } else {
            merged.back()[1] = max(merged.back()[1], interval[1]);
        }
    }
    return merged;
}


**Explanation:**
- Sort and merge overlapping intervals.
- Time Complexity: O(n log n)
