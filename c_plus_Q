````markdown
# 10 Must-Know Competitive Programming String Problems

| #  | Problem Title                  | Description                                             | Sample Input/Output & Explanation                                     |
|----|-------------------------------|---------------------------------------------------------|------------------------------------------------------------------------|
| 1  | Reverse a String               | Reverse the characters in a string.                     | Input: 'OpenAI' <br> Output: 'IAnepO' <br> Explanation: Reverse each character. |
| 2  | Check for Palindrome           | Check if a string reads the same backward.              | Input: 'madam' <br> Output: 'Yes' <br> Explanation: 'madam' is the same reversed. |
| 3  | Anagram Check                  | Check if two strings are anagrams of each other.        | Input: 'listen', 'silent' <br> Output: 'Anagram' <br> Explanation: Same letters in different order. |
| 4  | Remove Duplicates              | Remove duplicate characters from a string.              | Input: 'programming' <br> Output: 'progamin' <br> Explanation: Remove repeated chars, keep first appearance. |
| 5  | Longest Common Prefix          | Find the longest prefix common to all strings in array. | Input: ['flower', 'flow', 'flight'] <br> Output: 'fl' <br> Explanation: All words start with 'fl'. |
| 6  | Longest Palindromic Substring  | Find the longest palindrome substring.                  | Input: 'babad' <br> Output: 'bab' or 'aba' <br> Explanation: Both are valid palindromes of max length. |
| 7  | String Compression             | Compress consecutive repeating characters.              | Input: 'aabcccccaaa' <br> Output: 'a2b1c5a3' <br> Explanation: Replace sequences with character + count. |
| 8  | Substring Search (KMP)         | Check if pattern exists in text using KMP algorithm.    | Input: Text='abxabcabcaby', Pattern='abcaby' <br> Output: 'Found' <br> Explanation: Pattern found at index 6. |
| 9  | Remove All Adjacent Duplicates | Remove adjacent duplicates in one pass.                 | Input: 'abbaca' <br> Output: 'ca' <br> Explanation: Remove 'bb', then 'aa' leaves 'ca'. |
| 10 | Valid Parentheses              | Check for valid and balanced parentheses.               | Input: '{[()]}' <br> Output: 'Valid' <br> Explanation: All brackets closed in correct order. |

---

## 1. Reverse a String

Reverse the characters in a string.

```cpp
#include <iostream>
#include <string>
#include <algorithm>

int main() {
    std::string input = "OpenAI";
    std::reverse(input.begin(), input.end());
    std::cout << input << std::endl; // Output: IAnepO
    return 0;
}
````

---

## 2. Check for Palindrome

Check if a string reads the same backward.

```cpp
#include <iostream>
#include <string>

bool isPalindrome(const std::string& s) {
    int left = 0, right = s.size() - 1;
    while(left < right) {
        if(s[left] != s[right]) return false;
        left++; right--;
    }
    return true;
}

int main() {
    std::string s = "madam";
    if (isPalindrome(s))
        std::cout << "Yes\n"; // Output: Yes
    else
        std::cout << "No\n";
    return 0;
}
```

---

## 3. Anagram Check

Check if two strings are anagrams of each other.

```cpp
#include <iostream>
#include <string>
#include <algorithm>

bool areAnagrams(std::string s1, std::string s2) {
    if (s1.size() != s2.size()) return false;
    std::sort(s1.begin(), s1.end());
    std::sort(s2.begin(), s2.end());
    return s1 == s2;
}

int main() {
    std::string a = "listen", b = "silent";
    if (areAnagrams(a, b))
        std::cout << "Anagram\n"; // Output: Anagram
    else
        std::cout << "Not Anagram\n";
    return 0;
}
```

---

## 4. Remove Duplicates

Remove duplicate characters from a string, keeping first appearances.

```cpp
#include <iostream>
#include <string>
#include <unordered_set>

std::string removeDuplicates(const std::string& s) {
    std::unordered_set<char> seen;
    std::string result;
    for (char c : s) {
        if (seen.find(c) == seen.end()) {
            result.push_back(c);
            seen.insert(c);
        }
    }
    return result;
}

int main() {
    std::string s = "programming";
    std::cout << removeDuplicates(s) << std::endl; // Output: progamin
    return 0;
}
```

---

## 5. Longest Common Prefix

Find the longest prefix common to all strings in an array.

```cpp
#include <iostream>
#include <vector>
#include <string>

std::string longestCommonPrefix(const std::vector<std::string>& strs) {
    if (strs.empty()) return "";
    std::string prefix = strs[0];
    for (int i = 1; i < strs.size(); ++i) {
        while (strs[i].find(prefix) != 0) {
            prefix = prefix.substr(0, prefix.size() - 1);
            if (prefix.empty()) return "";
        }
    }
    return prefix;
}

int main() {
    std::vector<std::string> words = {"flower", "flow", "flight"};
    std::cout << longestCommonPrefix(words) << std::endl; // Output: fl
    return 0;
}
```

---

## 6. Longest Palindromic Substring

Find the longest palindrome substring.

```cpp
#include <iostream>
#include <string>

int expandAroundCenter(const std::string& s, int left, int right) {
    while (left >= 0 && right < s.size() && s[left] == s[right]) {
        left--;
        right++;
    }
    return right - left - 1;
}

std::string longestPalindrome(const std::string& s) {
    if (s.empty()) return "";
    int start = 0, end = 0;
    for (int i = 0; i < s.size(); i++) {
        int len1 = expandAroundCenter(s, i, i);
        int len2 = expandAroundCenter(s, i, i + 1);
        int len = std::max(len1, len2);
        if (len > end - start) {
            start = i - (len - 1) / 2;
            end = i + len / 2;
        }
    }
    return s.substr(start, end - start + 1);
}

int main() {
    std::string s = "babad";
    std::cout << longestPalindrome(s) << std::endl; // Output: bab or aba
    return 0;
}
```

---

## 7. String Compression

Compress consecutive repeating characters.

```cpp
#include <iostream>
#include <string>

std::string compressString(const std::string& s) {
    std::string result;
    int count = 1;
    for (int i = 1; i <= s.size(); i++) {
        if (i < s.size() && s[i] == s[i - 1]) {
            count++;
        } else {
            result += s[i - 1];
            result += std::to_string(count);
            count = 1;
        }
    }
    return result;
}

int main() {
    std::string s = "aabcccccaaa";
    std::cout << compressString(s) << std::endl; // Output: a2b1c5a3
    return 0;
}
```

---

## 8. Substring Search (KMP Algorithm)

Check if pattern exists in text using KMP algorithm.

```cpp
#include <iostream>
#include <vector>
#include <string>

std::vector<int> computeLPS(const std::string& pattern) {
    int length = 0;
    std::vector<int> lps(pattern.size(), 0);
    int i = 1;
    while (i < pattern.size()) {
        if (pattern[i] == pattern[length]) {
            length++;
            lps[i] = length;
            i++;
        } else {
            if (length != 0) {
                length = lps[length - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
    return lps;
}

bool KMPSearch(const std::string& text, const std::string& pattern) {
    std::vector<int> lps = computeLPS(pattern);
    int i = 0, j = 0;
    while (i < text.size()) {
        if (pattern[j] == text[i]) {
            i++; j++;
        }
        if (j == pattern.size()) {
            return true; // Found at index i - j
        } else if (i < text.size() && pattern[j] != text[i]) {
            if (j != 0) {
                j = lps[j - 1];
            } else {
                i++;
            }
        }
    }
    return false;
}

int main() {
    std::string text = "abxabcabcaby";
    std::string pattern = "abcaby";
    if (KMPSearch(text, pattern))
        std::cout << "Found\n"; // Output: Found
    else
        std::cout << "Not Found\n";
    return 0;
}
```


````


## 9. Remove All Adjacent Duplicates

Remove adjacent duplicates in one pass.

```cpp
#include <iostream>
#include <string>
#include <stack>
#include <algorithm>

std::string removeAdjacentDuplicates(const std::string& s) {
    std::stack<char> st;
    for (char c : s) {
        if (!st.empty() && st.top() == c) {
            st.pop(); // Remove duplicate
        } else {
            st.push(c);
        }
    }
    std::string result;
    while (!st.empty()) {
        result += st.top();
        st.pop();
    }
    std::reverse(result.begin(), result.end());
    return result;
}

int main() {
    std::string s = "abbaca";
    std::cout << removeAdjacentDuplicates(s) << std::endl; // Output: ca
    return 0;
}
````


## 10. Valid Parentheses

Check for valid and balanced parentheses.

```cpp
#include <iostream>
#include <stack>
#include <string>

bool isValidParentheses(const std::string& s) {
    std::stack<char> st;
    for (char c : s) {
        if (c == '(' || c == '{' || c == '[') {
            st.push(c);
        } else {
            if (st.empty()) return false;
            char top = st.top();
            if ((c == ')' && top != '(') ||
                (c == '}' && top != '{') ||
                (c == ']' && top != '['))
                return false;
            st.pop();
        }
    }
    return st.empty();
}

int main() {
    std::string s = "{[()]}";
    if (isValidParentheses(s))
        std::cout << "Valid\n"; // Output: Valid
    else
        std::cout << "Invalid\n";
    return 0;
}
```

---

---

## 1. Two Sum

**Problem:**
Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to the target.


**Solution:**
```cpp
#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

// Function to return indices of the two numbers that add up to the target
vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> map; // value -> index
    for (int i = 0; i < nums.size(); i++) {
        int complement = target - nums[i];
        if (map.find(complement) != map.end()) {
            return {map[complement], i};
        }
        map[nums[i]] = i;
    }
    return {}; // return empty if no solution found
}
```
**Explanation:**
- Use a hashmap to store visited numbers and their indices.
- For each element, check if `target - current` exists in the map.
- Time Complexity: O(n), Space Complexity: O(n)

---

## 2. Best Time to Buy and Sell Stock

**Problem:**
Given an array `prices` where `prices[i]` is the price of a given stock on the ith day, find the maximum profit.

**Solution:**
```cpp
#include <vector>
#include <algorithm>
using namespace std;

int maxProfit(vector<int>& prices) {
    int minPrice = INT_MAX;
    int maxProfit = 0;
    for (int price : prices) {
        minPrice = min(minPrice, price);
        maxProfit = max(maxProfit, price - minPrice);
    }
    return maxProfit;
}
```
**Explanation:**
- Track the minimum price so far.
- Calculate profit for each day.
- Time Complexity: O(n), Space Complexity: O(1)

---

## 3. Maximum Subarray (Kadane's Algorithm)

**Problem:**
Find the contiguous subarray with the largest sum.

**Solution:**
```cpp
#include <vector>
#include <algorithm>
using namespace std;

int maxSubArray(vector<int>& nums) {
    int maxCurrent = nums[0];
    int maxGlobal = nums[0];
    for (int i = 1; i < nums.size(); i++) {
        maxCurrent = max(nums[i], maxCurrent + nums[i]);
        maxGlobal = max(maxGlobal, maxCurrent);
    }
    return maxGlobal;
}
```
**Explanation:**
- At each step, decide to include current element or start new subarray.
- Time Complexity: O(n), Space Complexity: O(1)

---

## 4. Move Zeroes

**Problem:**
Move all 0's to the end while maintaining the relative order of non-zero elements.

**Solution:**
```cpp
#include <vector>
using namespace std;

void moveZeroes(vector<int>& nums) {
    int insertPos = 0;
    for (int num : nums) {
        if (num != 0) {
            nums[insertPos++] = num;
        }
    }
    while (insertPos < nums.size()) {
        nums[insertPos++] = 0;
    }
}
```
**Explanation:**
- Shift non-zero values forward, fill remaining with zero.
- Time Complexity: O(n), Space Complexity: O(1)

---

## 5. Contains Duplicate

**Problem:**
Check if any value appears at least twice in the array.

**Solution:**
```cpp
#include <unordered_set>
#include <vector>
using namespace std;

bool containsDuplicate(vector<int>& nums) {
    unordered_set<int> seen;
    for (int num : nums) {
        if (seen.count(num)) return true;
        seen.insert(num);
    }
    return false;
}
```
**Explanation:**
- Use set to track unique values.
- Time Complexity: O(n), Space Complexity: O(n)

---

## 6. Product of Array Except Self

**Problem:**
Return array such that output[i] is product of all elements except nums[i].

**Solution:**
```cpp
#include <vector>
using namespace std;

vector<int> productExceptSelf(vector<int>& nums) {
    int n = nums.size();
    vector<int> output(n, 1);

    int prefix = 1;
    for (int i = 0; i < n; i++) {
        output[i] = prefix;
        prefix *= nums[i];
    }

    int suffix = 1;
    for (int i = n - 1; i >= 0; i--) {
        output[i] *= suffix;
        suffix *= nums[i];
    }

    return output;
}
```
**Explanation:**
- Two passes: one for prefix, one for suffix.
- Time Complexity: O(n), Space: O(1) extra (output not counted)

---

## 7. Maximum Product Subarray

**Problem:**
Find the contiguous subarray within an array which has the largest product.

**Solution:**
```cpp
#include <vector>
#include <algorithm>
using namespace std;

int maxProduct(vector<int>& nums) {
    int maxProd = nums[0], minProd = nums[0], result = nums[0];
    for (int i = 1; i < nums.size(); i++) {
        if (nums[i] < 0) swap(maxProd, minProd);
        maxProd = max(nums[i], nums[i] * maxProd);
        minProd = min(nums[i], nums[i] * minProd);
        result = max(result, maxProd);
    }
    return result;
}
```
**Explanation:**
- Track both max and min products because of negatives.
- Time Complexity: O(n)

---

## 8. Find Minimum in Rotated Sorted Array

**Problem:**
Find the minimum element in a rotated sorted array.

**Solution:**
```cpp
#include <vector>
using namespace std;

int findMin(vector<int>& nums) {
    int left = 0, right = nums.size() - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] > nums[right])
            left = mid + 1;
        else
            right = mid;
    }
    return nums[left];
}
```
**Explanation:**
- Binary search variation.
- Time Complexity: O(log n)

---

## 9. Search in Rotated Sorted Array

**Problem:**
Given rotated sorted array and target, return index or -1.

**Solution:**
```cpp
#include <vector>
using namespace std;

int search(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) return mid;

        if (nums[left] <= nums[mid]) {
            if (nums[left] <= target && target < nums[mid])
                right = mid - 1;
            else
                left = mid + 1;
        } else {
            if (nums[mid] < target && target <= nums[right])
                left = mid + 1;
            else
                right = mid - 1;
        }
    }
    return -1;
}
```
**Explanation:**
- Binary search with rotation check.
- Time Complexity: O(log n)

---

## 10. Merge Intervals

**Problem:**
Merge all overlapping intervals.

**Solution:**
```cpp
#include <vector>
#include <algorithm>
using namespace std;

vector<vector<int>> merge(vector<vector<int>>& intervals) {
    if (intervals.empty()) return {};
    sort(intervals.begin(), intervals.end());
    vector<vector<int>> merged;

    for (const auto& interval : intervals) {
        if (merged.empty() || merged.back()[1] < interval[0]) {
            merged.push_back(interval);
        } else {
            merged.back()[1] = max(merged.back()[1], interval[1]);
        }
    }
    return merged;
}


**Explanation:**
- Sort and merge overlapping intervals.
- Time Complexity: O(n log n)
