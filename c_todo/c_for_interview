================================================================================================================================================
Static and Dynamic Linking of Libraries
=======================================
Static and dynamic linking are two processes of collecting and combining multiple object files in order to create a single executable. Linking can be performed at both compile time, when the source code is translated into machine code and load time, when the program is loaded into memory and executed by the loader, and even at run time, by application programs. And, it is performed by programs called linkers. Linkers are also called link editors. Linking is performed as the last step in compiling a program. In this tutorial static and dynamic linking with C modules will be discussed.
What is Linker?
==============
Linker is system software which plays crucial role in software development because it enables separate compilation. Instead of organizing a large application as one monolithic source file, you can decompose it into smaller, more manageable chunks that can be modified and compiled separately. When you change one of the modules, you simply recompile it and re-link the application, without recompiling the other source files.

During static linking the linker copies all library routines used in the program into the executable image. This of course takes more space on the disk and in memory than dynamic linking. But static linking is faster and more portable because it does not require the presence of the library on the system where it runs.

At the other hand, in dynamic linking shareable library name is placed in the executable image, while actual linking takes place at run time when both the executable and the library are placed in memory. Dynamic linking serves the advantage of sharing a single shareable library among multiple programs.

Linker as a system program takes relocatable object files and command line arguments in order to generate an executable object file. To produce an executable file the Linker has to perform the symbol resolution, and Relocation.

Note: Object files come in three flavors viz Relocatable, Executable, and Shared. Relocatable object files contain code and data in a form which can be combined with other object files of its kind at compile time to create an executable object file. They consist of various code and data sections. Instructions are in one section, initialized global variables in another section, and uninitialized variables are yet in another section. Executable object files contain binary code and data in a form which can directly be copied into memory and executed. Shared object files are files those can be loaded into memory and linked dynamically, at either load or run time by a linker.

Through this article, static and dynamic linking will be explained. While linking, the linker complains about missing function definitions, if there is any. During compilation, if compiler does not find a function definition for a particular module, it just assumes that the function is defined in another file, and treats it as an external reference. The compiler does not look at more than one file at a time. Whereas, linker may look at multiple files and seeks references for the modules that were not mentioned. The separate compilation and linking processes reduce the complexity of program and gives the ease to break code into smaller pieces which are better manageable.
What is Static Linking?
======================
Static linking is the process of copying all library modules used in the program into the final executable image. This is performed by the linker and it is done as the last step of the compilation process. The linker combines library routines with the program code in order to resolve external references, and to generate an executable image suitable for loading into memory.

Let's see static linking by example. Here, we will take a very simple example of adding two integer quantities to demonstrate the static linking process. We will develop an add module and place in a separate add.c file. Prototype of add module will be placed in a separate file called add.h. Code file addDemo.c will be created to demonstrate the linking process.

To begin with, create a header file add.h and insert the add function signature into that as follows:

int add(int, int);

Now, create another source code file viz addDemo.c, and insert the following code into that.

#include <add.h>
#include <stdio.h>
 
int main()
{
  int x= 10, y = 20;
  printf("\n%d + %d = %d", x, y, add(x, y));
  return 0;
}

Create one more file named add.c that contains the code of add module. Insert the following code into add.c

int add(int quant1, int quant2)
{
  return(quant1 + quant2);
}

After having created above files, you can start building the executable as follows:

[root@host ~]# gcc -I . -c addDemo.c

The -I option tells GCC to search for header files in the directory which is specified after it. Here, GCC is asked to look for header files in the current directory along with the include directory. (in Unix like systems, dot(.) is interpreted as current directory).

Note: Some applications use header files installed in /usr/local/include and while compiling them, they usually tell GCC to look for these header files there.

The -c option tells GCC to compile to an object file. The object file will have name as *.o. Where * is the name of file without extension. It will stop after that and won't perform the linking to create the executable.

As similar to the above command, compile add.c to create the object file. It is done by following command.

[root@host ~]# gcc -c add.c

This time the -I option has been omitted because add.c requires no header files to include. The above command will produce a new file viz add.o. Now the final step is to generate the executable by linking add.o, and addDemo.o together. Execute the following command to generate executable object file.

[root@host ~]# gcc -o addDemo add.o addDemo.o

Although, the linker could directly be invoked for this purpose by using ld command, but we preferred to do it through the compiler because there are other object files or paths or options, which must be linked in order to get the final executable. And so, ld command has been explained in detail in How to Compile a C Program section.

Now that we know how to create an executable object file from more than one binary object files. It's time to know about libraries. In the following section we will see what libraries are in software development process? How are they created? What is their significance in software development? How are they used, and many things which have made the use of libraries far obvious in software development?
How to Create Static Libraries?

Static and shared libraries are simply collections of binary object files they help during linking. A library contains hundreds or thousands of object files. During the demonstration of addDemo we had two object files viz add.o, and addDemo.o. There might be chances that you would have ten or more object files which have to be linked together in order to get the final executable object file. In those situations you will find yourself enervate, and every time you will have to specify a lengthy list of object files in order to get the final executable object file. Moreover, fenceless object files will be difficult to manage. Libraries solve all these difficulties, and help you to keep the organization of object files simple and maintainable.

Static libraries are explained here, dynamic libraries will be explained along with dynamic linking. Static libraries are bundle of relocatable object files. Usually they have .a extension. To demonstrate the use of static libraries we will extend the addDemo example further. So far we have add.o which contains the binary object code of add function which we used in addDemo. For more explanatory demonstration of use of libraries we would create a new header file heymath.h and will add signatures of two functions add, sub to that.

int add(int, int); //adds two integers
int sub(int, int); //subtracts second integer from first

Next, create a file sub.c, and add the following code to it. We have add.c already created.

int sub(int quant1, int quant2)
{
  return (quant1 - quant2);
}

Now compile sub.c as follows in order to get the binary object file.
[root@host ~]# gcc -c sub.c
Above command will produce binary object file sub.o.

Now, we have two binary object files viz add.o, and sub.o. We have add.o file in working directory as we have created it for previous example. If you have not done this so far then create the add.o from add.c in similar fashion as sub.o has been created. We will now create a static library by collecting both files together. It will make our final executable object file creation job easier and next time we will have not to specify two object files along with addDemo in order to generate the final executable object file. Create the static library libheymath by executing the following command:
[root@host ~]# ar rs libheymath.a add.o sub.o

The above command produces a new file libheymath.a, which is a static library containing two object files and can be used further as and when we wish to use add, or sub functions or both in our programs.

To use the sub function in addDemo we need to make a few changes in addDemo.c and will recompile it. Make the following changes in addDemo.c.

#include <heymath.h>
#include <stdio.h>
 
int main()
{
  int x = 10, y = 20;
  printf("\n%d + %d = %d", x, y, add(x, y));
  printf("\n%d + %d = %d", x, y, sub(x, y));
  return 0;
}

If you see, we have replaced the first statement #include <add.h> by #include <heymath.h>. Because heymath.h now contains the signatures of both add and sub functions and added one more printf statement which is calling the sub function to print the difference of variable x, and y.

Now remove all .o files from working directory (rm will help you to do that). Create addDemo.o as follows:
[root@host ~]# gcc -I . -c addDemo.c

And link it with heymath.a to generate final executable object file.
[root@host ~]# gcc -o addDemo addDemo.o libheymath.a

You can also use the following command as an alternate to link the libheymath.a with addDemo.o in order to generate the final executable file.
[root@host ~]# gcc -o addDemo -L . addDemo.o -lheymath

In above command -lheymath should be read as -l heymath which tells the linker to link the object files contained in lib<library>.a with addDemo to generate the executable object file. In our example this is libheymath.a.

The -L option tells the linker to search for libraries in the following argument (similar to how we did for -I). So, what we created as of now is a static library. But this is not the end; systems use a lot of dynamic libraries as well. It is the right time to discuss them.

What is Dynamic Linking?
=======================
Dynamic linking defers much of the linking process until a program starts running. It performs the linking process "on the fly" as programs are executed in the system. During dynamic linking the name of the shared library is placed in the final executable file while the actual linking takes place at run time when both executable file and library are placed in the memory. The main advantage to using dynamically linked libraries is that the size of executable programs is dramatically reduced because each program does not have to store redundant copies of the library functions that it uses. Also, when DLL functions are updated, programs that use them will automatically obtain their benefits.
How to Create and Use Shared Libraries?

A shared library (on Linux) or a dynamic link library (dll on Windows) is a collection of object files. In dynamic linking, object files are not combined with programs at compile time, also, they are not copied permanently into the final executable file; therefore, a shared library reduces the size of final executable.

Shared libraries or dynamic link libraries (dlls) serve a great advantage of sharing a single copy of library among multiple programs, hence they are called shared libraries, and the process of linking them with multiple programs is called dynamic linking.

Shared libraries are loaded into memory by programs when they start. When a shared library is loaded properly, all programs that start later automatically use the already loaded shared library. Following text will demonstrate how to create and use shared library on Linux.

Let's continue with the previous example of add, and sub modules. As you remember we had two object files add.o, and sub.o (compiled from add.c and sub.c) that contain code of add and sub methods respectively. But we will have to recompile both add.c and sub.c again with -fpic or -fPIC option. The -fPIC or -fpic option enable "position independent code" generation, a requirement for shared libraries. Use -fPIC or -fpic to generate code. Which option should be used, -fPIC or -fpic to generate code that is target-dependent. The -fPIC choice always works, but may produce larger code than -fpic. Using -fpic option usually generates smaller and faster code, but will have platform-dependent limitations, such as the number of globally visible symbols or the size of the code. The linker will tell you whether it fits when you create the shared library. When in doubt, I choose -fPIC, because it always works. So, while creating shared library you have to recompile both add.c, and sub.c with following options:
[root@host ~]# gcc -Wall -fPIC -c add.c
[root@host ~]# gcc -Wall -fPIC -c sub.c

Above commands will produce two fresh object files in current directory add.o, and sub.o. The warning option -Wall enables warnings for many common errors, and should always be used. It combines a large number of other, more specific, warning options which can also be selected individually. For details you can see man page for warnings specified.

Now build the library libheymath.so using the following command.
[root@host ~]# gcc -shared -o libheymath.so add.o sub.o

This newly created shared library libheymath.so can be used as a substitute of libheymath.a. But to use a shared library is not as straightforward as static library was. Once you create a shared library you will have to install it. And, the simplest approach of installation is to copy the library into one of the standard directories (e.g., /usr/lib) and run ldconfig command.

Thereafter executing ldconfig command, the addDemo executable can be built as follows. I recompile addDemo.c also. You can omit it if addDemo.o is already there in your working directory.

[root@host ~]# gcc -c addDemo.c
[root@host ~]# gcc -o addDemo addDemo.o libheymath.so
or
[root@host ~]# gcc -o addDemo addDemo.o -lheymath

You can list the shared library dependencies which your executable is dependent upon. The ldd <name-of-executable> command does that for you.
[root@host ~]# ldd addition
libheymath.so => /usr/lib/libheymath.so (0x00002b19378fa000)
libc.so.6 => /lib64/libc.so.6 (0x00002b1937afb000)
/lib64/ld-linux-x86-64.so.2 (0x00002b19376dd000)

================================================================================================================================================
What is a Storage Class?
========================
Storage class in C decides the part of storage to allocate memory for a variable, it also determines the scope of a variable. All variables defined in a C program get some physical location in memory where variable's value is stored. Memory and CPU registers are types of memory locations where a variable's value can be stored. The storage class of a variable in C determines the life time of the variable if this is 'global' or 'local'. Along with the life time of a variable, storage class also determines variable's storage location (memory or registers), the scope (visibility level) of the variable, and the initial value of the variable. There are four storage classes in C those are automatic, register, static, and external.
Storage Class Specifiers

There are four storage class specifiers in C as follows, typedef specifier does not reserve storage and is called a storage class specifier only for syntactic convenience. It is not a storage class specifier in the common meaning.

    auto
    register
    extern
    static
    typedef

These specifiers tell the compiler how to store the subsequent variable. The general form of a variable declaration that uses a storage class is shown here:

storage_class_specifier data_type variable_name;

At most one storage class specifier may be given in a declaration. If no storage class specifier is specified then following rules are used:

    Variables declared inside a function are taken to be auto.
    Functions declared within a function are taken to be extern.
    Variables and functions declared outside a function are taken to be static, with external linkage.

Variables and functions having external linkage are available to all files that constitute a program. File scope variables and functions declared as static (described shortly) have internal linkage. These are known only within the file in which they are declared. Local variables have no linkage and are therefore known only within their own block.
Types of Storage Classes

There are four storage classes in C they are as follows:

    Automatic Storage Class
    Register Storage Class
    Static Storage Class
    External Storage Class

Now, let us discuss these storage classes one by one.
1. Automatic Storage Class

A variable defined within a function or block with auto specifier belongs to automatic storage class. All variables defined within a function or block by default belong to automatic storage class if no storage class is mentioned. Variables having automatic storage class are local to the block which they are defined in, and get destroyed on exit from the block.

The following C program demonstrates the visibility level of auto variables.

#include <stdio.h>
int main( )
{
  auto int i = 1;
  {
    auto int i = 2;
    {
      auto int i = 3;
      printf ( "\n%d ", i);
    }
    printf ( "%d ", i);
  }
  printf( "%d\n", i);
}
 
OUTPUT
======
3 2 1

In above example program you see three definitions for variable i. Here, you may be thinking if there could be more than one variable with the same name. Yes, there could be if these variables are defined in different blocks. So, there will be no error here and the program will compile and execute successfully. The printf in the inner most block will print 3 and the variable i defined in the inner most block gets destroyed as soon as control exits from the block. Now control comes to the second outer block and prints 2 then comes to the outer block and prints 1. Here, note that automatic variables must always be initialized properly, otherwise you are likely to get unexpected results because automatic variables are not given any initial value by the compiler.
2. Register Storage Class

The register specifier declares a variable of register storage class. Variables belonging to register storage class are local to the block which they are defined in, and get destroyed on exit from the block. A register declaration is equivalent to an auto declaration, but hints that the declared variable will be accessed frequently; therefore they are placed in CPU registers, not in memory. Only a few variables are actually placed into registers, and only certain types are eligible; the restrictions are implementation-dependent. However, if a variable is declared register, the unary & (address of) operator may not be applied to it, explicitly or implicitly. Register variables are also given no initial value by the compiler.

The following piece of code is trying to get the address of variable i into pointer variable p but it won't succeed because i is declared register; therefore following piece of code won't compile and exit with error "error: address of register variable requested".

#include <stdio.h>
 
int main()
{
  register int i = 10;
  int *p = &i; //error: address of register variable requested
 
  printf("Value of i: %d", *p);
  printf("Address of i: %u", p);
 
}

3. Static Storage Class

The static specifier gives the declared variable static storage class. Static variables can be used within function or file.Unlike global variables, static variables are not visible outside their function or file, but they maintain their values between calls. The static specifier has different effects upon local and global variables. See the following flavours of static specifier.

    When static specifier is applied to a local variable inside a function or block, the compiler creates permanent storage for it, much as it creates storage for a global variable but static local variable remains visible only to the function or block in which it is defined. In simple terms, a static local variable is a local variable that retains its value between function calls. For example, the following program code defines static variable i at two places in two blocks inside function staticDemo(). Function staticDemo() is called twice within from main function. During second call static variables retain their old values and they are not initialized again in second call of staticDemo().

    #include <stdio.h>
     
    void staticDemo()
    {
      static int i;
      {
        static int i = 1;
        printf("%d ", i);
        i++;
      }
      printf("%d\n", i);
      i++;
    }
     
    int main()
    {
      staticDemo();
      staticDemo();
    }
    OUTPUT
    ======
    1 0
    2 1

    When static specifier is applied to a global variable or a function then compiler makes that variable or function known only to the file in which it is defined. A static global variable has internal linkage that means even though the variable is global; routines in other files have no knowledge of it and cannot access and alter its contents directly. The following C program defines one static global variable gInt and a static function staticDemo(), for the variable and function are defined static they cannot be used outside the file (translation unit) staticdemo.c..

    /* staticdemo.c */
    #include <stdio.h>
    static int gInt = 1;
    static void staticDemo()
    {
      static int i;
      printf("%d ", i);
      i++;
      printf("%d\n", gInt);
      gInt++;
    }
     
    int main()
    {
      staticDemo();
      staticDemo();
    }
    OUTPUT
    ======
    0 1
    1 2

Static variables have default initial value zero and initialized only once in their lifetime.
4. External Storage Class

The extern specifier gives the declared variable external storage class. The principal use of extern is to specify that a variable is declared with external linkage elsewhere in the program. To understand why this is important, it is necessary to understand the difference between a declaration and a definition. A declaration declares the name and type of a variable or function. A definition causes storage to be allocated for the variable or the body of the function to be defined. The same variable or function may have many declarations, but there can be only one definition for that variable or function.

When extern specifier is used with a variable declaration then no storage is allocated to that variable and it is assumed that the variable has already been defined elsewhere in the program. When we use extern specifier the variable cannot be initialized because with extern specifier variable is declared, not defined.

In the following sample C program if you remove extern int x; you will get an error "Undeclared identifier 'x'" because variable x is defined later than it has been used in printf. In this example, the extern specifier tells the compiler that variable x has already been defined and it is declared here for compiler's information.

#include <stdio.h>
 
extern int x;
 
int main()
{
  printf("x: %d\n", x);
}
 
int x = 10;

Also, if you change the statement extern int x; to extern int x = 50; you will again get an error "Redefinition of 'x'" because with extern specifier the variable cannot be initialized, if it is defined elsewhere. If not then extern declaration becomes a definition.

Note that extern can also be applied to a function declaration, but doing so is redundant because all function declarations are implicitly extern. 
================================================================================================================================================
source:c_2vid
pointer to an array==>
===================
int main() 
{ 
  int arr[5] = { 1, 2, 3, 4, 5 }; 
  int *ptr = arr; 
  
  printf("%p\n", ptr); 
  return 0; 
} 

In this program, we have a pointer ptr that points to the 0th element of the array. Similarly, we can also declare a pointer that can point to whole array instead of only one element of the array. This pointer is useful when talking about multidimensional arrays.
Syntax:

data_type (*var_name)[size_of_array];

Example:
int (*ptr)[10];

1)pointer to an array is basically used in 2d array.with declaration style (*ptr)[3] and can be accessed has arr[0],arr[1].
2)pointer is storing 2d array address(whole address).but when accessed *ptr it gives the address.
3)pointer arthematic for 2d(pointer to an array) pointer makes them jump block size .
4)double dereference is required to access any element value in it.
5)when passaed to an function it can be like this 
   example:void sub_one(int (*arr)[7]) or arr[2][7].


Here ptr is pointer that can point to an array of 10 integers. Since subscript have higher precedence than indirection, it is necessary to enclose the indirection operator and pointer name inside parentheses. Here the type of ptr is ‘pointer to an array of 10 integers’.
Note : The pointer that points to the 0th element of array and the pointer that points to the whole array are totally different.

#include<stdio.h> 
  
int main() 
{ 
    // Pointer to an integer 
    int *p;  
      
    // Pointer to an array of 5 integers 
    int (*ptr)[5];  
    int arr[5]; 
      
    // Points to 0th element of the arr. 
    p = arr; 
      
    // Points to the whole array arr. 
    ptr = &arr;  
      
    printf("p = %p, ptr = %p\n", p, ptr); 
      
    p++;  
    ptr++; 
      
    printf("p = %p, ptr = %p\n", p, ptr); 
      
    return 0; 
} 

Output:

p = 0x7fff4f32fd50, ptr = 0x7fff4f32fd50
p = 0x7fff4f32fd54, ptr = 0x7fff4f32fd64

p: is pointer to 0th element of the array arr, while ptr is a pointer that points to the whole array arr.

    The base type of p is int while base type of ptr is ‘an array of 5 integers’.
    We know that the pointer arithmetic is performed relative to the base size, so if we write ptr++, then the pointer ptr will be shifted forward by 20 bytes.

The following figure shows the pointer p and ptr. Darker arrow denotes pointer to an array.

On dereferencing a pointer expression we get a value pointed to by that pointer expression. Pointer to an array points to an array, so on dereferencing it, we should get the array, and the name of array denotes the base address. So whenever a pointer to an array is dereferenced, we get the base address of the array to which it points.

=============================================================================================================================================
array of pointers
=================

In general, an array of pointers can be used to point to an array of data items with each element of the pointer array pointing to an element of the data array. Data items can be accessed either directly in the data array, or indirectly by dereferencing the elements of the pointer array. The advantage of a pointer array is that the pointers can be reordered in any manner without moving the data items. For example, the pointer array can be reordered so that the successive elements of the pointer array point to data items in sorted order without moving the data items. Reordering pointers is relatively fast compared to reordering large data items such as data records or strings. This approach saves a lot of time, with the additional advantage that the data items remain available in the original order.


so basically it is an array of pointers example :int *arr[3] means its an array of 4 integer pointers *arr[0] to *arr[3].
which in turn is same as normal integer pointers .so same arthematic operations and size of pointer.
can reperesent bunch of values or bunch of strings or 1d arrays in memory.
great tool for sorting/reordering values  without messing the memory.


==============================================================================================================================================
constant pointers And pointer to an constant integer
====================================================
1) Constant Pointers : These type of pointers are the one which cannot change address they are pointing to. This means that suppose there is a pointer which points to a variable (or stores the address of that variable). Now if we try to point the pointer to some other variable (or try to make the pointer store address of some other variable), then constant pointers are incapable of this.

A constant pointer is declared as : int *const ptr ( the location of 'const' make the pointer 'ptr' as constant pointer)

2) Pointer to Constant : These type of pointers are the one which cannot change the value they are pointing to. This means they cannot change the value of the variable whose address they are holding.

A pointer to a constant is declared as : const int *ptr (the location of 'const' makes the pointer 'ptr' as a pointer to constant.



const int* ptr; 

declares ptr a pointer to const int type. You can modify ptr itself but the object pointed to by ptr shall not be modified.

const int a = 10;
const int* ptr = &a;  
*ptr = 5; // wrong
ptr++;    // right  

While

int * const ptr;  

declares ptr a const pointer to int type. You are not allowed to modify ptr but the object pointed to by ptr.

int a = 10;
int *const ptr = &a;  
*ptr = 5; // right
ptr++;    // wrong

Generally I would prefer the declaration like this which make it easy to read and understand (read from right to left):

int const  *ptr; // ptr is a pointer to constant int 
int *const ptr;  // ptr is a constant pointer to int

==============================================================================================================================================
void pointer
============
”. A void pointer is nothing but a pointer variable declared using the reserved word in C ‘void’. 

    Ex:-   void  *ptr; // Now ptr is a general purpose pointer variable

When a pointer variable is declared using keyword void – it becomes a general purpose pointer variable. Address of any variable of any data type (char, int, float etc.)can be assigned to a void pointer variable.
Dereferencing a void pointer

We have seen about dereferencing a pointer variable in our article – Introduction to pointers in C. We use the indirection operator * to serve the purpose. But in the case of a void pointer we need to typecast the pointer variable to dereference it. This is because a void pointer has no data type associated with it. There is no way the compiler can know (or guess?) what type of data is pointed to by the void pointer. So to take the data pointed to by a void pointer we typecast it with the correct type of the data holded inside the void pointers location. 
Example program:- 

#include

void main()

{

int a=10;

float b=35.75;

void *ptr; // Declaring a void pointer

ptr=&a; // Assigning address of integer to void pointer.

printf("The value of integer variable is= %d",*( (int*) ptr) );// (int*)ptr - is used for type casting. Where as *((int*)ptr) dereferences the typecasted void pointer variable.

ptr=&b; // Assigning address of float to void pointer.

printf("The value of float variable is= %f",*( (float*) ptr) );

}
The output:- 

The value of integer variable is= 10

The value of float variable is= 37.75

A void pointer can be really useful if the programmer is not sure about the data type of data inputted by the end user. In such a case the programmer can use a void pointer to point to the location of the unknown data type. The program can be set in such a way to ask the user to inform the type of data and type casting can be performed according to the information inputted by the user. A code snippet is given below.

void funct(void *a, int z)
{
if(z==1)
printf("%d",*(int*)a); // If user inputs 1, then he means the data is an integer and type casting is done accordingly.
else if(z==2)
printf("%c",*(char*)a); // Typecasting for character pointer.
else if(z==3)
printf("%f",*(float*)a); // Typecasting for float pointer
}

 

Another important point you should keep in mind about void pointers is that – pointer arithmetic can not be performed in a void pointer. 

Example:- 

void *ptr;

int a;

ptr=&a;

ptr++; // This statement is invalid and will result in an error because 'ptr' is a void pointer variable.
===============================================================================================================================================
typedef
=======

===============================================================================================================================================
structure
=========


    A structure in C is a collection of items of different types. You can think of a structure as a class in Java without methods.
or in other words. 

    Structures can store non-homogenous data types into a single collection, much like an array does for common data (except it isn't accessed in the same manner).
    Structures, or structs, are very useful in creating data structures larger and more complex than the ones we have discussed so far. We will take a cursory look at some more complex ones in the next section.

Structures :: Declaration and Syntax

    So how is a structure declared and initialized? Let's look at an example:

      struct student {
        char *first;
        char *last;
        char SSN[9];
        float gpa;
        char **classes;
      };

      struct student student_a, student_b;

    Another way to declare the same thing is:

      struct {
        char *first;
        char *last;
        char SSN[10];
        float gpa;
        char **classes;
      } student_a, student_b;

    As you can see, the tag immediately after struct is optional. But in the second case, if you wanted to declare another struct later, you couldn't.
    The "better" method of initializing structs is:

      struct student_t {
        char *first;
        char *last;
        char SSN[10];
        float gpa;
        char **classes;
      } student, *pstudent;

    Now we have created a student_t student and a student_t pointer. The pointer allows us greater flexibility (e.g. Create lists of students).
    How do you go about initializing a struct? You could do it just like an array initialization. But be careful, you can't initialize this struct at declaration time because of the pointers.
    But how do we access fields inside of the structure? C has a special operator for this called "member of" operator denoted by . (period). For example, to assign the SSN of student_a:

      strcpy(student_a.SSN, "111223333\0");

Structures :: Pointers to Structs

    Sometimes it is useful to assign pointers to structures (this will be evident in the next section with self-referential structures). Declaring pointers to structures is basically the same as declaring a normal pointer:

      struct student *student_a;

    But how do we dereference the pointer to the struct and its fields? You can do it in one of two ways, the first way is:

      printf("%s\n", (*student_a).SSN);

    This would get the SSN in student_a. Messy and the readability is horrible! Is there a better way? Of course, programmers are lazy! :)
    To dereference, you can use the infix operator: ->. The above example using the new operator:

      printf("%s\n", student_a->SSN);

    If we malloc'd space for the structure for *student_a could we start assigning things to pointer fields inside the structure? No. You must malloc space for each individual pointer within the structure that is being pointed to.

Structures :: typedef

    There is an easier way to define structs or you could "alias" types you create. For example:

      typedef struct {
        char *first;
        char *last;
        char SSN[9];
        float gpa;
        char **classes;
      } student;

      student student_a;

    Now we get rid of those silly struct tags. You can use typedef for non-structs:

      typedef long int *pint32;

      pint32 x, y, z;

    x, y and z are all pointers to long ints. typedef is your friend. Use it.

Structures :: Unions

    Unions are declared in the same fashion as structs, but have a fundamental difference. Only one item within the union can be used at any time, because the memory allocated for each item inside the union is in a shared memory location. Why you ask? An example first:

      struct conditions {
        float temp;
        union feels_like {
          float wind_chill;
          float heat_index;
        }
      } today;

    As you know, wind_chill is only calculated when it is "cold" and heat_index when it is "hot". There is no need for both. So when you specify the temp in today, feels_like only has one value, either a float for wind_chill or a float for heat_index.
    Types inside of unions are unrestricted, you can even use structs within unions.

Structures :: Enumerated Types

    What if you wanted a series of constants without creating a new type? Enter enumerated types. Say you wanted an "array" of months in a year:

      enum e_months {JAN=1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC};
      typedef enum e_months month;

      month currentmonth;
      currentmonth = JUN;      /* same as currentmonth = 6; */
      printf("%d\n", currentmonth);

    We are enumerating the months in a year into a type called month. You aren't creating a type, because enumerated types are simply integers. Thus the printf statement uses %d, not %s.
    If you notice the first month, JAN=1 tells C to make the enumeration start at 1 instead of 0.
    Note: This would be almost the same as using:

    #define JAN 1
    #define FEB 2
    #define MAR 3
    /* ... etc ... */

Structures :: Abilities and Limitations

    You can create arrays of structs.
    Structs can be copied or assigned.
    The & operator may be used with structs to show addresses.
    Structs can be passed into functions. Structs can also be returned from functions.
    Structs cannot be compared!

Structures Review

    Structures can store non-homogenous data types into a single collection, much like an array does for common data (except it isn't accessed in the same manner).
    Pointers to structs have a special infix operator: -> for dereferencing the pointer.
    typedef can help you clear your code up and can help save some keystrokes.
    Enumerated types allow you to have a series of constants much like a series of #define statements
===============================================================================================================================================
function pointers
=================

===============================================================================================================================================
Structure Alignment, Padding and Data Packing in C
==================================================
Why Struct Members are Aligned?

In this article we will focus on member alignment within structures in C; but before that let's see why is data alignment important? All processors are architectured to achieve optimal performance and to make memory access faster. Aligning data elements allows the processor to fetch data from memory in an efficient way and thereby improves performance.

By definition, Alignment refers to the location of data in memory; means which address data should be stored at. A variable is naturally aligned if it gets stored at a memory address that is a multiple of its size. For example, a 32-bit long variable is naturally aligned if it is located in memory at an address that is a multiple of four. Alignment in C is defined as a "requirement that data of a particular type be located on storage boundaries with addresses that are particular multiples of a byte address".
Structure Alignment and Padding

Now that we know a variable stored in memory should be stored at the address divisible by its size; therefore, the random order of variables declared with in a structure can cause memory wastage. We can try to minimize this memory wastage by ordering the structure elements such that the widest (largest) element comes first, followed by the second widest, and so on. The following example helps illustrate the effect of ordering of data elements on the size of the structure. The following trivial C program I executed on a x86_64 Linux box, where you can see the order of members proves to be useful in optimizing the memory usage.

#include <stdio.h>
 
int main()
{
  //declare members in random order
  typedef struct
  {
   char ch1; short sh1;
   char ch2; float fl1;
   int in1; char ch3;
   double dbl1;
  }random_struct;
 
  //declare members from largest to smallest order
  typedef struct
  {
   double dbl1; float fl1;
   int in1; short sh1;
   char ch1, ch2, ch3;
  }ordered_struct;
 
 
  random_struct s1;
  ordered_struct s2;
  printf("Size of s1: %d\n", sizeof(s1));
  printf("Size of s1: %d\n", sizeof(s2));
}
 
OUTPUT
======
Size of s1: 32
Size of s1: 24

order of member declaration within a structure greatly helps reducing memory holes, this is because padding bits are left blank if any data member is not getting an address divisible of its size.
================================================================================================================================================
